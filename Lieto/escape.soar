##RECAP: 
# Dobbiamo avere:
# - operatori di movimento, immaginiamo destra e sinistra?
# - Uno o più operatori di combinazioni di oggetti, cosa creano, quali #sono ammissibli e quelli non ammissibili devono avere rinforzo negativo, NB: dopo la combinazione NON li togliamo dal mondo, perchè gli oggetti originali non servono per risolvere il problema, non li riutilizza ma usa solo quelli combinati.
# - Oggetti: devono essere descritti -> ci possiamo fare alcune cose e non altre
# - Finestra: è un oggetto, ma alcuni attributi della finestra servono ad identificare lo stato goal che vogliamo raggiungere. (rotta/intera)
# - Definire l'agente, come l'altezza
# - Definire la finestra, come l’altezza della finestra
# - Dobbiamo definire le proprietà che rendono la finestra rompibile in alcuni punti e su azioni ripetute
# - L'agente deve saper afferrare degli oggetti, combinarli, lanciare (lanciare forse no, dipende come lo progettiamo), deve saper salire
# - Trovare un modo poco scontato per rompere la finestra, guardare la consegna!
# - Modelliamo solo gli elementi di conoscenza che servono all'agente rispetto al goal, dovendosi muovere direi che la dimensione della stanza è importante
##

##
# Per runnare ricorda: 
#     - load 
#     - watch 5 
#     - Step (se vuoi)
#     - print --full --rl
#     - Run 
#     - print --full --rl
#     - print --rl
#     - se vuoi vedere l'apprendimento fai init-soar e riparti dalla quinta istruzione! :)  
##

##TODO: 
# 1. Far muovere questo agente                                                              OK
# 2. Definire la finestra, in particolare la sua altezza (NB: h 3.5)                        OK
# 3. Dagli struttura, è importante per noi la sua altezza (1.5 metri)                       OK
# 4. Fai raggiungere l'agente la stessa pos della finestra per arrivarci con i due tronchi  OK? ne discutiamo un attimo
# 5. Definire gli oggetti: molla, rametto in legno, pietre, 2 tronchi di legno              OK
# 6. Aggiungere un reward per la creazione degli oggetti definiti come nella consegna       OK 
# 7. Capire come gestire il fatto di rompere la finestra 
# 8. Capire come gestire il fatto di salire e uscire dalla stanza                                               OK

#################################################################################################BEGIN



##
###	I.	Propose the top space
###
### The code in this section proposes a simple space to work in, and a
### simple state to start working in.

sp {propose*initialize-es
    (state <s> -^name ^superstate nil)
    -->
    (<s> ^operator <o> +)
    (<o> ^name initialize-escape)
}

##
# Store the available directions
# and associated reward on the state
##
sp {apply*initialize-escape
   (state <s> ^operator <o>)
   (<o> ^name initialize-escape)
    -->
   (<s> ^name escape
        ^location <loc>
        ^desired <d>
        ^window <f>
        ^robot <r>
        ^spring yes
        ^sprig yes
        ^stone 5
        ^trunck yes
        ^comb <c1> <c2> <c3> <c4> <c5>)
   (<num> ^val 5)
   (<loc> ^x 5.0 ^y 3.0)      
   (<d> ^x 3.0 ^y 4.0)
   (<f> ^broken no ^height 3.5)
   (<r> ^height 1.5)
   (<c1> ^name stone-sprig
         ^built no
         ^reward -1)
   (<c2> ^name spring-sprig
         ^built no
         ^reward +1)
   (<c3> ^name stone-spring
         ^built no
         ^reward -1)
   (<c4> ^name stone-trunck
         ^built no
         ^reward -1)
   (<c5> ^name truncks
         ^built no
         ^reward +1)
}


###
###	II.	Propose the main operators
###
### The code in this section proposes the four operators left, right, backward and forward. 

##
# Propose rule for moving left
##
sp {es*propose*left
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> > <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir left)
}

##
# Propose rule for moving right 
##

sp {es*propose*right
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> < <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir right)
}


##
# Propose rule for moving backward
##

sp {es*propose*backward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^y <val2>)
   (<loc> ^y <val1> > <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir backward)
}

##
# Propose rule for moving forward
##

sp {es*propose*forward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^y <val2>)
   (<loc> ^y <val1> < <val2>)      
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir forward)
}

##
# Propose rule for moving up with truncks
##

#sp {es*propose*up
#   (state <s> ^desired <d>
#              ^location <loc>
#              ^comb <c>
#              ^robot <r>
#              ^window <f>)
#   (<d> ^x <val1> ^y <val2>)
#   (<loc> ^x <val1> ^y <val2>)      ##bisogna essere nella stessa pos della finestra
#   (<f> ^height <val3>)
#   (<r> ^height <val4> < <val3>)  #non sono ancora arrivata alla finestra
#   (<c> ^name truncks ^built yes)   ##bisogna avere i tronchi
#    -->
#   (<s> ^operator <op>)
#   (<op> ^name move
#         ^dir up)
#}


##
# Comparison between movements
##

sp {es*compare*right*better*forward
  (state <s> ^desired <d>
             ^location <loc>)
  (<d> ^x <val2>)
  (<loc> ^x <val1> < <val2>) 
  (<s> ^operator <op-right> +)
  (<op-right> ^name move
              ^dir right)
  (<s> ^operator <op-forward> +)
  (<op-forward> ^name move
                ^dir forward)
  -->
  (<s> ^operator <op-right> > <op-forward>)
}

sp {es*compare*right*better*backward
  (state <s> ^desired <d>
             ^location <loc>)
  (<d> ^x <val2>)
  (<loc> ^x <val1> < <val2>) 
  (<s> ^operator <op-right> +)
  (<op-right> ^name move
              ^dir right)
  (<s> ^operator <op-backward> +)
  (<op-backward> ^name move
                ^dir backward)
  -->
  (<s> ^operator <op-right> > <op-backward>)
}

sp {es*compare*left*better*backward
  (state <s> ^desired <d>
             ^location <loc>)
  (<d> ^x <val2>)
  (<loc> ^x <val1> > <val2>) 
  (<s> ^operator <op-left> +)
  (<op-left> ^name move
             ^dir left)
  (<s> ^operator <op-backward> +)
  (<op-backward> ^name move
                 ^dir backward)
  -->
  (<s> ^operator <op-left> > <op-backward>)
}  


sp {es*compare*left*better*forward
  (state <s> ^desired <d>
             ^location <loc>)
  (<d> ^x <val2>)
  (<loc> ^x <val1> > <val2>) 
  (<s> ^operator <op-left> +)
  (<op-left> ^name move
             ^dir left)
  (<s> ^operator <op-forward> +)
  (<op-forward> ^name move
                 ^dir forward)
  -->
  (<s> ^operator <op-left> > <op-forward>)
}  

###
###	III.	Implement the main operators
###

## Implement the operators with productions that modify the state once
## the operators have been selected, and then terminate them after
## they have done

## what they need to do
##
## Note: We make the new value acceptable and reject the previous
## value.

##
## The reconsider preference effectively terminates the operator on 
## the next decision cycle after it has done what its supposed to do.

sp {es*apply-op*left
  (state <s>  ^operator <o>
              ^location <loc>)
  (<o> ^name move
       ^dir left)
  (<loc> ^x <val>)
  -->
  (<loc> ^x <val> - (- <val> 0.5))
  (write (crlf) |          Moved: left! | current | | location: | x: | (- <val> 0.5))
  (<s> ^operator <o> -)
}


## Implement right

sp {es*apply-op*right
  (state <s>  ^operator <o>
              ^location <loc>)
  (<o> ^name move
       ^dir right)
  (<loc> ^x <val>)
  -->
  (<loc> ^x <val> - (+ <val> 0.5))
  (write (crlf) |          Moved: right! | current | | location: | x: | (+ <val> 0.5))
  (<s> ^operator <o> -)
}

## Implement backward

sp {es*apply-op*backward
  (state <s>  ^operator <o>
              ^location <loc>)
  (<o> ^name move
       ^dir backward)
  (<loc> ^y <val>)
  -->
  (<loc> ^y <val> - (- <val> 0.5))
  (write (crlf) |          Moved: backward! | current | | location: | y: | (- <val> 0.5))
  (<s> ^operator <o> -)
}


## Implement forward

sp {es*apply-op*forward
  (state <s>  ^operator <o>
              ^location <loc>)
  (<o> ^name move
       ^dir forward)
  (<loc> ^y <val>)
  -->
  (<loc> ^y <val> - (+ <val> 0.5))
  (write (crlf) |          Moved: forward! | current | | location: | y: | (+ <val> 0.5))
  (<s> ^operator <o> -)
}


## Implement up

#sp {es*apply-op*up
#  (state <s>  ^operator <o>
#              ^robot <r>)
#  (<o> ^name move
#       ^dir up)
#  (<r> ^height <val>)
#  -->
#  (<r> ^height <val> - (+ <val> 0.5))
#  (write (crlf) |          Moved: up! | current | | location: | height: | (+ <val> 0.5))
#  (<s> ^operator <o> -)
#}


###
###	IV.		Propose the main operators to combine objects into a useful object to escape the room
###

## Propose to combine of stone and sprig of wood
sp {es*propose*combine*stone*sprig
   (state <s> ^window <f>
              ^sprig yes
              ^comb <c>)
   (<f> broken no)  
   (<s> ^stone <num> > 0)    
   (<c> ^name stone-sprig 
        ^built no)     
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine 
         ^obj stone-sprig)
}

## Propose to combine of spring and sprig of wood

sp {es*propose*combine*spring*sprig
   (state <s> ^window <f>
              ^spring yes
              ^sprig yes
              ^comb <c>)
   (<f> broken no) 
   (<c> ^name spring-sprig
        ^built no)     
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine 
         ^obj spring-sprig)
}

## Propose to combine of stone and spring

sp {es*propose*combine*stone*spring
   (state <s> ^window <f>
              ^spring yes
              ^comb <c>)
   (<f> broken no)
   (<s> ^stone <num> > 0) 
   (<c> ^name stone-spring
        ^built no)     
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine 
         ^obj stone-spring)
}

## Propose to combine of stone and trunck

sp {es*propose*combine*stone*trunck
   (state <s> ^window <f>
              ^trunck yes
              ^comb <c>)
   (<f> broken no)
   (<s> ^stone <num> > 0) 
   (<c> ^name stone-trunck
        ^built no)     
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine 
         ^obj stone-trunck)
}


## Propose to combine of truncks

sp {es*propose*combine*stone*trunck
   (state <s> ^window <f>
              ^trunck yes
              ^comb <c>)
   (<f> broken no)
   (<c> ^name truncks
        ^built no)     
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine 
         ^obj truncks)
}


###
### V.     Soar reinforcement learning for the main operators that combine objects into a useful object to escape the room
###

## Soar-RL rule for combine of stone and sprig of wood -1

sp {es*rl*combine*stone*sprig
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-sprigs)
-->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of spring and sprig of wood +1

sp {es*rl*combine*sprig*wood
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj sprig-wood)
-->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of stone and spring -1

sp {es*rl*combine*stone*spring
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-spring)
-->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of stone and trunck -1

sp {es*rl*combine*stone*trunck
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-trunk)
-->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of truck +1 -> mi serve per salire su e uscire dalla stanza

sp {es*rl*combine*stone*sprig
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj trunks)
-->
   (<s> ^operator <op> = 0)
}

##
# When a combine is chosen:
# - change object built
# - output built
##
sp {apply*combine
   (state <s> ^operator <op>)
   (<op> ^name combine
         ^obj <obj>)
-->
   (<s> ^comb <c>)
   (<c> ^name <obj>
        ^built yes)
   (write (crlf) |Built: | <obj>)
}

##
# When a combine is chosen, assert the associated reward
##
sp {elaborate*reward
   (state <s> ^reward-link <r>
              ^combine <dir>)
   (<dir> ^name <d-name> 
          ^reward <d-reward>
          ^built yes)
-->
   (<r> ^reward <rr>)
   (<rr> ^value <d-reward>)
}



###
###	VII.	Propose and apply to go out of the room
###

## Se è rotta e sono alla finestra allora esco. 
#sp {es*propose*out
#   (state <s> ^desired <d>
#              ^location <loc>
#              ^robot <r>
#              ^window <f>)
#   (<d> ^x <val1> ^y <val2>)
#   (<loc> ^x <val1> ^y <val2>)
#   (<r> ^height <h>)
#   (<f> ^height <h>
#        ^broken yes) 
#    -->
#   (<s> ^operator <op>)
#   (<op> ^name move
#         ^dir out)
#}


#sp {es*apply-op*out
#  (state <s>  ^operator <o>)
#  (<o> ^name move
#       ^dir out)
#  -->
#  (<s> ^out no - yes)
#  (write (crlf) |          Moved: out! )
#  (<s> ^operator <o> -)
#}


###
###	VIII.	Noticing when goal is reached
###
### This code terminates the problem solving when the goal is reached. 
### --QUANDO SONO FUORI DALLA STANZA HO RAGGIUNTO IL GOAL out è yes!


## How to tell if you can stop
sp {es*evaluate*state*success
  (state <s> ^desired <d>
             ^location <loc>)
  (<d> ^x <val1> ^y <val2>)
  (<loc> ^x <val1> ^y <val2>)
  -->
  (<s> ^success <d>)
}


## One of the default rules is brought in to notice that we are 
## finished.  (Slightly modified to be more compact and less general.)

sp {default*top-goal*halt*state*success
    :default
  (state <s>  ^desired <eb>) 
  (<s> ^success <eb>)
  -->
  (write (crlf)  |  goal for  | <s>  | achieved | )
  (halt)
}
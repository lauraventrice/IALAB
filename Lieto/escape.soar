##RECAP: 
# Dobbiamo avere:
# - operatori di movimento, immaginiamo destra e sinistra?
# - Uno o più operatori di combinazioni di oggetti, cosa creano, quali #sono ammissibli e quelli non ammissibili devono avere rinforzo negativo, NB: dopo la combinazione NON li togliamo dal mondo, perchè gli oggetti originali non servono per risolvere il problema, non li riutilizza ma usa solo quelli combinati.
# - Oggetti: devono essere descritti -> ci possiamo fare alcune cose e non altre
# - Finestra: è un oggetto, ma alcuni attributi della finestra servono ad identificare lo stato goal che vogliamo raggiungere. (rotta/intera)
# - Definire l'agente, come l'altezza
# - Definire la finestra, come l’altezza della finestra
# - Dobbiamo definire le proprietà che rendono la finestra rompibile in alcuni punti e su azioni ripetute
# - L'agente deve saper afferrare degli oggetti, combinarli, lanciare (lanciare forse no, dipende come lo progettiamo), deve saper salire
# - Trovare un modo poco scontato per rompere la finestra, guardare la consegna!
# - Modelliamo solo gli elementi di conoscenza che servono all'agente rispetto al goal, dovendosi muovere direi che la dimensione della stanza è importante
##

##
# Per runnare ricorda: 
#     - load 
#     - watch 5 
#     - Step (se vuoi)
#     - print --full --rl
#     - Run 
#     - print --full --rl
#     - print --rl
#     - se vuoi vedere l'apprendimento fai init-soar e riparti dalla quinta istruzione! :)  
##

##TODO: 
# 1. Far muovere questo agente                                                              OK
# 2. Definire la finestra, in particolare la sua altezza (NB: h 3.5)                        OK
# 3. Dagli struttura, è importante per noi la sua altezza (1.5 metri)                       OK
# 4. Fai raggiungere l'agente la stessa pos della finestra per arrivarci con i due tronchi  OK? ne discutiamo un attimo
# 5. Definire gli oggetti: molla, rametto in legno, pietre, 2 tronchi di legno              OK
# 6. Aggiungere un reward per la creazione degli oggetti definiti come nella consegna       OK 
# 7. Capire come gestire il fatto di rompere la finestra 
# 8. Capire come gestire il fatto di salire e uscire dalla stanza                           OK

#################################################################################################BEGIN

rl -s learning on # enable RL
indifferent-selection -g # use epsilon-greedy decision making
indifferent-selection -e 0.1 # 10% deviation from greedy


##
###	I.	Propose the top space
###
### The code in this section proposes a simple space to work in, and a
### simple state to start working in.

sp {propose*initialize-es
   (state <s> -^name ^superstate nil)
    -->
   (<s> ^operator <o> +)
   (<o> ^name initialize-escape)
}

##
# Store the available directions
# and associated reward on the state
##
sp {apply*initialize-escape
   (state <s> ^operator <o>)
   (<o> ^name initialize-escape)
    -->
   (<s> ^name escape
        ^location <loc>
        ^desired <d>
        ^window <f>
        ^robot <r>
        ^spring yes
        ^sprig yes
        ^stone 5
        ^trunk yes
        ^comb <c1> <c2> <c3> <c4> <c5>
        ^out no)
   (<loc> ^x 5.0 ^y 3.0)      
   (<d> ^x 3.0 ^y 4.0)
   (<f> ^broken no ^height 3.5)
   (<r> ^height 1.5)
   (<c1> ^name stone-sprig
         ^built no
         ^reward -1)
   (<c2> ^name spring-sprig
         ^built no
         ^reward 1)
   (<c3> ^name stone-spring
         ^built no
         ^reward -1)
   (<c4> ^name stone-trunk
         ^built no
         ^reward -1)
   (<c5> ^name trunks
         ^built no
         ^reward 1)
}


###
###	II.	Propose the main operators
###
### The code in this section proposes the four operators left, right, backward and forward. 

##
# Propose rule for moving left
##
sp {es*propose*left
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> > <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir left)
}

##
# Propose rule for moving right 
##

sp {es*propose*right
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> < <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir right)
}


##
# Propose rule for moving backward
##

sp {es*propose*backward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^y <val2>)
   (<loc> ^y <val1> > <val2>)
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir backward)
}

##
# Propose rule for moving forward
##

sp {es*propose*forward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^y <val2>)
   (<loc> ^y <val1> < <val2>)      
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir forward)
}

##
# Propose rule for moving up with trunks
##

sp {es*propose*up
   (state <s> ^desired <d>
              ^location <loc>
              ^comb <c>
              ^robot <r>
              ^window <f>)
   (<d> ^x <val1> ^y <val2>)
   (<loc> ^x <val1> ^y <val2>)      
   (<f> ^height <val3>)
   (<r> ^height <val4> < <val3>)  
   (<c> ^name trunks ^built yes)  
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir up)
}


##
# Comparison between movements
##

sp {es*compare*right*better*forward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> < <val2>) 
   (<s> ^operator <op-right> +)
   (<op-right> ^name move
               ^dir right)
   (<s> ^operator <op-forward> +)
   (<op-forward> ^name move
                 ^dir forward)
    -->
   (<s> ^operator <op-right> > <op-forward>)
}

sp {es*compare*right*better*backward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> < <val2>) 
   (<s> ^operator <op-right> +)
   (<op-right> ^name move
               ^dir right)
   (<s> ^operator <op-backward> +)
   (<op-backward> ^name move
                 ^dir backward)
    -->
   (<s> ^operator <op-right> > <op-backward>)
}

sp {es*compare*left*better*backward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> > <val2>) 
   (<s> ^operator <op-left> +)
   (<op-left> ^name move
              ^dir left)
   (<s> ^operator <op-backward> +)
   (<op-backward> ^name move
                  ^dir backward)
    -->
   (<s> ^operator <op-left> > <op-backward>)
}  


sp {es*compare*left*better*forward
   (state <s> ^desired <d>
              ^location <loc>)
   (<d> ^x <val2>)
   (<loc> ^x <val1> > <val2>) 
   (<s> ^operator <op-left> +)
   (<op-left> ^name move
              ^dir left)
   (<s> ^operator <op-forward> +)
   (<op-forward> ^name move
                 ^dir forward)
    -->
   (<s> ^operator <op-left> > <op-forward>)
}  

###
###	III.	Implement the main operators
###

## Implement the operators with productions that modify the state once
## the operators have been selected, and then terminate them after
## they have done

## what they need to do
##
## Note: We make the new value acceptable and reject the previous
## value.

##
## The reconsider preference effectively terminates the operator on 
## the next decision cycle after it has done what its supposed to do.

sp {es*apply-op*left
   (state <s>  ^operator <o>
               ^location <loc>)
   (<o> ^name move
        ^dir left)
   (<loc> ^x <val>)
    -->
   (<loc> ^x <val> - (- <val> 0.5))
   (write (crlf) |          Moved: left! | current | | location: | x: | (- <val> 0.5))
   (<s> ^operator <o> -)
}


## Implement right

sp {es*apply-op*right
   (state <s>  ^operator <o>
               ^location <loc>)
   (<o> ^name move
        ^dir right)
   (<loc> ^x <val>)
    -->
   (<loc> ^x <val> - (+ <val> 0.5))
   (write (crlf) |          Moved: right! | current | | location: | x: | (+ <val> 0.5))
   (<s> ^operator <o> -)
}

## Implement backward

sp {es*apply-op*backward
   (state <s>  ^operator <o>
               ^location <loc>)
   (<o> ^name move
        ^dir backward)
   (<loc> ^y <val>)
    -->
   (<loc> ^y <val> - (- <val> 0.5))
   (write (crlf) |          Moved: backward! | current | | location: | y: | (- <val> 0.5))
   (<s> ^operator <o> -)
}


## Implement forward

sp {es*apply-op*forward
   (state <s>  ^operator <o>
               ^location <loc>)
   (<o> ^name move
       ^dir forward)
   (<loc> ^y <val>)
    -->
   (<loc> ^y <val> - (+ <val> 0.5))
   (write (crlf) |          Moved: forward! | current | | location: | y: | (+ <val> 0.5))
   (<s> ^operator <o> -)
}


## Implement up

sp {es*apply-op*up
   (state <s>  ^operator <o>
               ^robot <r>)
   (<o> ^name move
       ^dir up)
   (<r> ^height <val>)
    -->
   (<r> ^height <val> - (+ <val> 0.5))
   (write (crlf) |          Moved: up! | current | | location | height: | (+ <val> 0.5))
   (<s> ^operator <o> -)
}


###
###	IV.		Propose the main operators to combine objects into a useful object to escape the room
###

sp {es*propose*combine
   (state <s> ^window <f>
              ^comb <c>
              ^location <loc>
              ^desired <d>)
   (<f> ^broken no)   
   (<c> ^name <obj> 
        ^built no)
   (<loc> ^x <val1> ^y <val2>)
   (<d> ^x <val1> ^y <val2>)
    -->
   (<s> ^operator <op> +)
   (<op> ^name combine
         ^obj <obj>)
}



## Propose to combine of stone and sprig of wood
##sp {es*propose*combine*stone*sprig
##   (state <s> ^window <f>
##              ^sprig yes
##              ^comb <c>
##              ^location <loc>
##              ^desired <d>)
##   (<f> ^broken no)  
##   (<s> ^stone <num> > 0)    
##   (<c> ^name stone-sprig 
##        ^built no)
##   (<loc> ^x <val1> ^y <val2>)
##   (<d> ^x <val1> ^y <val2>)
##    -->
##   (<s> ^operator <op> +)
##   (<op> ^name combine 
##         ^obj stone-sprig)
## }

## Propose to combine of spring and sprig of wood

## sp {es*propose*combine*spring*sprig
##   (state <s> ^window <f>
##              ^spring yes
##              ^sprig yes
##              ^comb <c>
##              ^location <loc>
##              ^desired <d>)
##   (<f> ^broken no) 
##   (<c> ^name spring-sprig
##        ^built no)
##   (<loc> ^x <val1> ^y <val2>)
##   (<d> ^x <val1> ^y <val2>)
##    -->
##   (<s> ^operator <op> +)
##   (<op> ^name combine 
##         ^obj spring-sprig)
##}

## Propose to combine of stone and spring

##sp {es*propose*combine*stone*spring
##   (state <s> ^window <f>
##              ^spring yes
##              ^comb <c>
##              ^location <loc>
##              ^desired <d>)
##   (<f> ^broken no)
##   (<s> ^stone <num> > 0) 
##   (<c> ^name stone-spring
##        ^built no)     
##   (<loc> ^x <val1> ^y <val2>)
##   (<d> ^x <val1> ^y <val2>)
##    -->
##   (<s> ^operator <op> +)
##   (<op> ^name combine 
##         ^obj stone-spring)
##}

## Propose to combine of stone and trunk

##sp {es*propose*combine*stone*trunk
##   (state <s> ^window <f>
##              ^trunk yes
##              ^comb <c>
##              ^location <loc>
##              ^desired <d>)
##   (<f> ^broken no)
##   (<s> ^stone <num> > 0) 
##   (<c> ^name stone-trunk
##        ^built no)     
##   (<loc> ^x <val1> ^y <val2>)
##   (<d> ^x <val1> ^y <val2>)
##    -->
##   (<s> ^operator <op> +)
##   (<op> ^name combine 
##         ^obj stone-trunk)
##}


## Propose to combine of trunks

##sp {es*propose*combine*trunks
##   (state <s> ^window <f>
##              ^trunk yes
##              ^comb <c>
##              ^desired <d>
##              ^location <loc>)
##   (<f> ^broken no)
##   (<c> ^name trunks
##        ^built no)   
##   (<loc> ^x <val1> ^y <val2>)
##   (<d> ^x <val1> ^y <val2>)
##    -->
##   (<s> ^operator <op> +)
##   (<op> ^name combine 
##         ^obj trunks)
##}


##sp {es*compare*move*better*combine
##   (state <s> ^operator <op-move> +)
##   (<op-move> ^name move)
##   (<s> ^operator <op-combine> +)
##   (<op-combine> ^name combine)
##    -->
##   (<s> ^operator <op-move> > <op-combine>)
##}

###
### V.     Soar reinforcement learning for the main operators that combine objects into a useful object to escape the room
###

## Soar-RL rule for combine of stone and sprig of wood -1

sp {es*rl*combine*stone*sprig
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-sprigs)
    -->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of spring and sprig of wood +1

sp {es*rl*combine*sprig*wood
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj sprig-wood)
    -->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of stone and spring -1

sp {es*rl*combine*stone*spring
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-spring)
    -->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of stone and trunk -1

sp {es*rl*combine*stone*trunk
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj stone-trunk)
    -->
   (<s> ^operator <op> = 0)
}

## Soar-RL rule for combine of trunk +1 -> mi serve per salire su e uscire dalla stanza

sp {es*rl*combine*trunks
   (state <s> ^operator <op> +)
   (<op> ^name combine
         ^obj trunks)
    -->
   (<s> ^operator <op> = 0)
}

##
# When a combine is chosen:
# - change object built
# - output built
##
sp {apply*combine
   (state <s> ^operator <op>
              ^comb <c>)
   (<op> ^name combine
         ^obj <obj>)
   (<c> ^name <obj>
        ^built no)
    -->
   (<c> ^built no - yes)
   (write (crlf) |Built: | <obj>)
   (<s> ^operator <op> -)
}

##
# When a combine is chosen, assert the associated reward
##
sp {elaborate*reward
   (state <s> ^reward-link <r>
              ^comb <c>)
   (<c> ^name <d-name> 
        ^reward <d-reward>
        ^built yes)
    -->
   (<r> ^reward <rr>)
   (<rr> ^value <d-reward>)
}

###
### VI. Propose and apply the main operator to break the window throwing stones
###


sp {es*propose*stone*throwing
   (state <s> ^window <f>
              ^comb <c>)
   (<f> ^broken no)
   (<c> ^name spring-sprig
        ^built yes)     
    -->
   (<s> ^operator <op>)
   (<op> ^name throw)
}

sp {es*apply-op*stone*throwing
   (state <s> ^operator <o>
              ^window <f>)        
   (<o> ^name throw)
   (<f> ^broken no)    
    -->
   (write (crlf) |          Stone throwing! |)
   (<f> ^broken no - yes)
   (<s> ^operator <o> -)
}

###
###	VIII.	Propose and apply to go out of the room
###

## Se è rotta e sono alla finestra allora esco. 
sp {es*propose*out
   (state <s> ^desired <d>
              ^location <loc>
              ^robot <r>
              ^window <f>)
   (<d> ^x <val1> ^y <val2>)
   (<loc> ^x <val1> ^y <val2>)
   (<r> ^height <h>)
   (<f> ^height <h>
        ^broken yes) 
    -->
   (<s> ^operator <op>)
   (<op> ^name move
         ^dir out)
}


sp {es*apply-op*out
   (state <s>  ^operator <o>)
   (<o> ^name move
        ^dir out)
    -->
   (<s> ^out no - yes)
   (write (crlf) |          Moved: out! )
   (<s> ^operator <o> -)
}


###
###	IX.	Noticing when goal is reached
###
### This code terminates the problem solving when the goal is reached.


## How to tell if you can stop
sp {es*evaluate*state*success
   (state <s> ^out yes
              ^desired <d>)
    -->
   (<s> ^success <d>)
}


## One of the default rules is brought in to notice that we are 
## finished.  (Slightly modified to be more compact and less general.)

sp {default*top-goal*halt*state*success
    :default
   (state <s>  ^desired <eb>) 
   (<s> ^success <eb>)
    -->
   (write (crlf)  |  goal for  | <s>  | achieved )
   (halt)
}